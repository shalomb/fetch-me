#!/bin/bash

# install-cmd

# Install a (CLI) application directly from its github release.

set -eu -o pipefail

VERSION=0.1

[[ ${DEBUG-} ]] && set -xv

os=$(uname -o)
arch=$(uname -m)
arch_regex="${arch}|${arch#a}"
if [[ $arch == "aarch"* ]]; then
  arch_regex="${arch_regex}|arm64"
fi
distribution=$(awk -F= '$1=="ID"{print $2}' /etc/os-release)

XDG_BIN_DIR="$(readlink -f "${XDG_DATA_HOME}/../bin")"
CACHE_DIR="${XDG_CACHE_HOME}/install-cmd"

die() {
  echo >&2 "$@"
  exit 3
}

get-gh-artifact() {
  local repo="${1%/}"
  local type="${2-}"  # latest
  local url="https://api.github.com/repos/${repo}/releases/${type}"
  local url="${url%/}"
  local cache="$CACHE_DIR/$repo"
  mkdir -p "$cache"
  if [[ -z $type ]]; then
    local artifact="$cache/${url##*/}"
  else
    local artifact="$cache/$type"
  fi
  local one_day_ago=$(date -d 'now - 1 days' +%s &>/dev/null)
  local artifact_mtime=$(date -r "$artifact" +%s &>/dev/null)
  if (( artifact_mtime <= one_day_ago )); then
    rm -f "$artifact"
    wget -qc "$url" -O "$artifact"
  fi
  jq -Ser '.' "$artifact"
}

get-release() {
  local repo="$1"
  get-gh-artifact "$repo" | jq -Ser '.'
}

get-latest() {
  local repo="${1%/}"
  get-gh-artifact "$repo" latest | jq -Ser '.tag_name'
}

install-candidate() {
  local candidate="$1"
  local url="$2"
  local repo="$3"
  local command="$4"
  local cache="$CACHE_DIR/$repo/${candidate%/*}"
  local file="$cache/${url##*/}"
  echo
  echo "Installing $url"
  mkdir -p "$cache"
  wget -qc "$url" -O "$file"

  file_type=$(file -i "$file" | awk -F'[;: ]' '{print $3}')
  case "$file_type" in
    application/x-executable)
      install -m=555 "$file" "$XDG_BIN_DIR/$command"
    ;;
    application/gzip)
      tar xf "$file" -C "$cache"
      cd "$cache"
      find . -maxdepth 1 -type f -executable -exec sh -c 'for i; do install -v -m=555 $i '"$XDG_BIN_DIR"'; done' _ {} +
    ;;
    application/vnd.debian.binary-package)
      sudo apt install "$file"
    ;;
  esac
}


show-help() {
  cat <<EOF

 $0 [-hvc args] repo [command]

    -t   tag/version release to install
    -c   command to install repo as
    -a   arch to use in search
    -s   request sudo for privileged installs
    -V   print version

USAGE:
  $0 sharkdp/bat          # common case - bat is installed as bat
  $0 sharkdp/bat bat-cmd  # expose the command as bat-cmd(1)
  $0 sharkdp/bat -v 0.20  # specifically install v0.20
EOF
}

# Due to the limitation in getopts where dashed parameters cannot follow
# arguments, we'll do a naive collection of the arguments upfront and break
# as soon as we see anything look like a parameters.

# This is to support the simple use-cases like
#    $0 sharkdp/bat -v 0.20
# but not
#    $0 sharkdp/bat -v 0.20 bat
# We'll assume that the first argument is always the short repo and the
# subsequent arguments the command, etc that pertain to the installation

args=()
while :; do
  if (( $# == 0 )); then
    break
  fi
  if [[ $1 != -* ]]; then
    args+=("$1")
    shift
  elif [[ $1 == -* ]]; then
    break
  fi
done

repo=
tag=
command=
sudo=0
while getopts ":a:c:hst:V" opt; do
  case $opt in
    a)
      arch_regex="$OPTARG"
    ;;
    c)
      command="$OPTARG"
    ;;
    h)
      show-help; exit 0;
    ;;
    s)
      sudo=1
    ;;
    V)
      echo "$0 $VERSION"; exit;
    ;;
    t)
      tag="$OPTARG"
    ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
    ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      exit 1
    ;;
  esac
done
shift $((OPTIND-1))

(( ${#args[@]} > 0 )) && set -- "${args[@]}" "$@"

[[ ${DEBUG-} ]] && echo "args: $@"

[[ -z $repo ]] && repo="$1"; shift
repo="${repo#https://github.com/}"

[[ -z $command ]] && command="${1-}"; shift || true
[[ -z $command ]] && command="${repo#*/}"

(( $# > 0 )) && die "Superfluous arguments: $@"

[[ -z $tag ]] && tag=$(get-latest "$repo")
tag="${tag//[\+]/\\\\+}"

echo
echo "repo:    $repo"
echo "command: $command"
echo "tag:     $tag"
echo "arch:    $arch_regex"
echo

json=$(get-release "$repo" | jq -S '.[] | select(.tag_name|test("^v?'"$tag"'"))')
candidates=($(
  jq -Scer '
    .assets[].browser_download_url |
      select(.|test("'"${arch_regex}"'")) |
      capture("download/(?<ver>.+)").ver
  ' <<<"$json" | sort
))

if (( ${#candidates[@]} == 0 )); then
  die "No candidates found for $repo ($arch)"
fi

candidate=
if (( ${#candidates[@]} > 0 )); then
  echo "Multiple candidates found"
  for i in ${!candidates[@]}; do
    printf '%3d - %s\n' "$i" "${candidates[$i]}"
  done
  read -p 'Which one? [0] '
  REPLY="${REPLY:-0}"
  candidate=${candidates[$REPLY]}
fi

url=$(
  jq -Scer '
    .assets[].browser_download_url | select(.|test("'"$candidate"'$"))
  ' <<<"$json" || true
)

install-candidate "$candidate" "$url" "$repo" "$command"
